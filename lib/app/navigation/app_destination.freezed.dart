// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'app_destination.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$HomeDestinationTearOff {
  const _$HomeDestinationTearOff();

  _HomeDestination call() {
    return const _HomeDestination();
  }
}

/// @nodoc
const $HomeDestination = _$HomeDestinationTearOff();

/// @nodoc
mixin _$HomeDestination {}

/// @nodoc
abstract class $HomeDestinationCopyWith<$Res> {
  factory $HomeDestinationCopyWith(
          HomeDestination value, $Res Function(HomeDestination) then) =
      _$HomeDestinationCopyWithImpl<$Res>;
}

/// @nodoc
class _$HomeDestinationCopyWithImpl<$Res>
    implements $HomeDestinationCopyWith<$Res> {
  _$HomeDestinationCopyWithImpl(this._value, this._then);

  final HomeDestination _value;
  // ignore: unused_field
  final $Res Function(HomeDestination) _then;
}

/// @nodoc
abstract class _$HomeDestinationCopyWith<$Res> {
  factory _$HomeDestinationCopyWith(
          _HomeDestination value, $Res Function(_HomeDestination) then) =
      __$HomeDestinationCopyWithImpl<$Res>;
}

/// @nodoc
class __$HomeDestinationCopyWithImpl<$Res>
    extends _$HomeDestinationCopyWithImpl<$Res>
    implements _$HomeDestinationCopyWith<$Res> {
  __$HomeDestinationCopyWithImpl(
      _HomeDestination _value, $Res Function(_HomeDestination) _then)
      : super(_value, (v) => _then(v as _HomeDestination));

  @override
  _HomeDestination get _value => super._value as _HomeDestination;
}

/// @nodoc

class _$_HomeDestination extends _HomeDestination {
  const _$_HomeDestination() : super._();

  @override
  String toString() {
    return 'HomeDestination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _HomeDestination);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _HomeDestination extends HomeDestination {
  const factory _HomeDestination() = _$_HomeDestination;
  const _HomeDestination._() : super._();
}

/// @nodoc
class _$SearchResultDestinationTearOff {
  const _$SearchResultDestinationTearOff();

  _SearchResultDestination call({required String query}) {
    return _SearchResultDestination(
      query: query,
    );
  }
}

/// @nodoc
const $SearchResultDestination = _$SearchResultDestinationTearOff();

/// @nodoc
mixin _$SearchResultDestination {
  String get query => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SearchResultDestinationCopyWith<SearchResultDestination> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchResultDestinationCopyWith<$Res> {
  factory $SearchResultDestinationCopyWith(SearchResultDestination value,
          $Res Function(SearchResultDestination) then) =
      _$SearchResultDestinationCopyWithImpl<$Res>;
  $Res call({String query});
}

/// @nodoc
class _$SearchResultDestinationCopyWithImpl<$Res>
    implements $SearchResultDestinationCopyWith<$Res> {
  _$SearchResultDestinationCopyWithImpl(this._value, this._then);

  final SearchResultDestination _value;
  // ignore: unused_field
  final $Res Function(SearchResultDestination) _then;

  @override
  $Res call({
    Object? query = freezed,
  }) {
    return _then(_value.copyWith(
      query: query == freezed
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$SearchResultDestinationCopyWith<$Res>
    implements $SearchResultDestinationCopyWith<$Res> {
  factory _$SearchResultDestinationCopyWith(_SearchResultDestination value,
          $Res Function(_SearchResultDestination) then) =
      __$SearchResultDestinationCopyWithImpl<$Res>;
  @override
  $Res call({String query});
}

/// @nodoc
class __$SearchResultDestinationCopyWithImpl<$Res>
    extends _$SearchResultDestinationCopyWithImpl<$Res>
    implements _$SearchResultDestinationCopyWith<$Res> {
  __$SearchResultDestinationCopyWithImpl(_SearchResultDestination _value,
      $Res Function(_SearchResultDestination) _then)
      : super(_value, (v) => _then(v as _SearchResultDestination));

  @override
  _SearchResultDestination get _value =>
      super._value as _SearchResultDestination;

  @override
  $Res call({
    Object? query = freezed,
  }) {
    return _then(_SearchResultDestination(
      query: query == freezed
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_SearchResultDestination extends _SearchResultDestination {
  const _$_SearchResultDestination({required this.query}) : super._();

  @override
  final String query;

  @override
  String toString() {
    return 'SearchResultDestination(query: $query)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SearchResultDestination &&
            (identical(other.query, query) || other.query == query));
  }

  @override
  int get hashCode => Object.hash(runtimeType, query);

  @JsonKey(ignore: true)
  @override
  _$SearchResultDestinationCopyWith<_SearchResultDestination> get copyWith =>
      __$SearchResultDestinationCopyWithImpl<_SearchResultDestination>(
          this, _$identity);
}

abstract class _SearchResultDestination extends SearchResultDestination {
  const factory _SearchResultDestination({required String query}) =
      _$_SearchResultDestination;
  const _SearchResultDestination._() : super._();

  @override
  String get query;
  @override
  @JsonKey(ignore: true)
  _$SearchResultDestinationCopyWith<_SearchResultDestination> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$DetailDestinationTearOff {
  const _$DetailDestinationTearOff();

  _DetailDestination call({required String title}) {
    return _DetailDestination(
      title: title,
    );
  }
}

/// @nodoc
const $DetailDestination = _$DetailDestinationTearOff();

/// @nodoc
mixin _$DetailDestination {
  String get title => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DetailDestinationCopyWith<DetailDestination> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DetailDestinationCopyWith<$Res> {
  factory $DetailDestinationCopyWith(
          DetailDestination value, $Res Function(DetailDestination) then) =
      _$DetailDestinationCopyWithImpl<$Res>;
  $Res call({String title});
}

/// @nodoc
class _$DetailDestinationCopyWithImpl<$Res>
    implements $DetailDestinationCopyWith<$Res> {
  _$DetailDestinationCopyWithImpl(this._value, this._then);

  final DetailDestination _value;
  // ignore: unused_field
  final $Res Function(DetailDestination) _then;

  @override
  $Res call({
    Object? title = freezed,
  }) {
    return _then(_value.copyWith(
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$DetailDestinationCopyWith<$Res>
    implements $DetailDestinationCopyWith<$Res> {
  factory _$DetailDestinationCopyWith(
          _DetailDestination value, $Res Function(_DetailDestination) then) =
      __$DetailDestinationCopyWithImpl<$Res>;
  @override
  $Res call({String title});
}

/// @nodoc
class __$DetailDestinationCopyWithImpl<$Res>
    extends _$DetailDestinationCopyWithImpl<$Res>
    implements _$DetailDestinationCopyWith<$Res> {
  __$DetailDestinationCopyWithImpl(
      _DetailDestination _value, $Res Function(_DetailDestination) _then)
      : super(_value, (v) => _then(v as _DetailDestination));

  @override
  _DetailDestination get _value => super._value as _DetailDestination;

  @override
  $Res call({
    Object? title = freezed,
  }) {
    return _then(_DetailDestination(
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_DetailDestination extends _DetailDestination {
  const _$_DetailDestination({required this.title}) : super._();

  @override
  final String title;

  @override
  String toString() {
    return 'DetailDestination(title: $title)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DetailDestination &&
            (identical(other.title, title) || other.title == title));
  }

  @override
  int get hashCode => Object.hash(runtimeType, title);

  @JsonKey(ignore: true)
  @override
  _$DetailDestinationCopyWith<_DetailDestination> get copyWith =>
      __$DetailDestinationCopyWithImpl<_DetailDestination>(this, _$identity);
}

abstract class _DetailDestination extends DetailDestination {
  const factory _DetailDestination({required String title}) =
      _$_DetailDestination;
  const _DetailDestination._() : super._();

  @override
  String get title;
  @override
  @JsonKey(ignore: true)
  _$DetailDestinationCopyWith<_DetailDestination> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ActionDestinationTearOff {
  const _$ActionDestinationTearOff();

  _ActionDestination call() {
    return const _ActionDestination();
  }
}

/// @nodoc
const $ActionDestination = _$ActionDestinationTearOff();

/// @nodoc
mixin _$ActionDestination {}

/// @nodoc
abstract class $ActionDestinationCopyWith<$Res> {
  factory $ActionDestinationCopyWith(
          ActionDestination value, $Res Function(ActionDestination) then) =
      _$ActionDestinationCopyWithImpl<$Res>;
}

/// @nodoc
class _$ActionDestinationCopyWithImpl<$Res>
    implements $ActionDestinationCopyWith<$Res> {
  _$ActionDestinationCopyWithImpl(this._value, this._then);

  final ActionDestination _value;
  // ignore: unused_field
  final $Res Function(ActionDestination) _then;
}

/// @nodoc
abstract class _$ActionDestinationCopyWith<$Res> {
  factory _$ActionDestinationCopyWith(
          _ActionDestination value, $Res Function(_ActionDestination) then) =
      __$ActionDestinationCopyWithImpl<$Res>;
}

/// @nodoc
class __$ActionDestinationCopyWithImpl<$Res>
    extends _$ActionDestinationCopyWithImpl<$Res>
    implements _$ActionDestinationCopyWith<$Res> {
  __$ActionDestinationCopyWithImpl(
      _ActionDestination _value, $Res Function(_ActionDestination) _then)
      : super(_value, (v) => _then(v as _ActionDestination));

  @override
  _ActionDestination get _value => super._value as _ActionDestination;
}

/// @nodoc

class _$_ActionDestination extends _ActionDestination {
  const _$_ActionDestination() : super._();

  @override
  String toString() {
    return 'ActionDestination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ActionDestination);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _ActionDestination extends ActionDestination {
  const factory _ActionDestination() = _$_ActionDestination;
  const _ActionDestination._() : super._();
}

/// @nodoc
class _$SettingsDestinationTearOff {
  const _$SettingsDestinationTearOff();

  _SettingsDestination call() {
    return const _SettingsDestination();
  }
}

/// @nodoc
const $SettingsDestination = _$SettingsDestinationTearOff();

/// @nodoc
mixin _$SettingsDestination {}

/// @nodoc
abstract class $SettingsDestinationCopyWith<$Res> {
  factory $SettingsDestinationCopyWith(
          SettingsDestination value, $Res Function(SettingsDestination) then) =
      _$SettingsDestinationCopyWithImpl<$Res>;
}

/// @nodoc
class _$SettingsDestinationCopyWithImpl<$Res>
    implements $SettingsDestinationCopyWith<$Res> {
  _$SettingsDestinationCopyWithImpl(this._value, this._then);

  final SettingsDestination _value;
  // ignore: unused_field
  final $Res Function(SettingsDestination) _then;
}

/// @nodoc
abstract class _$SettingsDestinationCopyWith<$Res> {
  factory _$SettingsDestinationCopyWith(_SettingsDestination value,
          $Res Function(_SettingsDestination) then) =
      __$SettingsDestinationCopyWithImpl<$Res>;
}

/// @nodoc
class __$SettingsDestinationCopyWithImpl<$Res>
    extends _$SettingsDestinationCopyWithImpl<$Res>
    implements _$SettingsDestinationCopyWith<$Res> {
  __$SettingsDestinationCopyWithImpl(
      _SettingsDestination _value, $Res Function(_SettingsDestination) _then)
      : super(_value, (v) => _then(v as _SettingsDestination));

  @override
  _SettingsDestination get _value => super._value as _SettingsDestination;
}

/// @nodoc

class _$_SettingsDestination extends _SettingsDestination {
  const _$_SettingsDestination() : super._();

  @override
  String toString() {
    return 'SettingsDestination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _SettingsDestination);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SettingsDestination extends SettingsDestination {
  const factory _SettingsDestination() = _$_SettingsDestination;
  const _SettingsDestination._() : super._();
}
